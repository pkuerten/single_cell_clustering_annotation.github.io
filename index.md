#  Single Cell Workshop - Clustering and cell type identification
Asif Javed

## Data download
We will use a PBMC dataset containing about 10K cells. This dataset was made publicly availablbe by 10X Genomics and can be downloaded from: [link to data](https://www.dropbox.com/s/wn4mgwkkzqw2pox/SC3_v3_NextGem_DI_PBMC_10K_filtered_feature_bc_matrix.h5?dl=0)

Please copy this dataset to the working directory you intend to use for the workshop.

## Prerequisite
The workshop content is inspired by multiple <a href="https://satijalab.org/seurat/articles/get_started.html">Seurat vignettes</a>. It assumes you are 
familiar with the initial quality control. It starts from the data x cell filtered matrix generated by cellranger; a common starting point for most analysis. 

We will focus on two specific key tasks for single cell RNA sequencing analysis: clustering and annotation of the identified clusters.

## Install packages 
Let's start by installing the necessary packages one by one
```r
# install packages
install.packages('Seurat')
```

```r
install.packages("hdf5r")
```

```r
install.packages("clustree")
```
And loading them into R.
```r
# load into your session
library(dplyr)
library(Seurat)
library(patchwork)
library(clustree)
```
## Read in the dataset and Create a Seurat object

The first step is to read 10X sequencing data and convert it to a seurat object. The Seurat object serves as a container that initially holds just the UMI count 
matrix. But throughout the workshop, we add further analysis content to it (e.g. PCA, clustering results). You can learn more about the `Seurat object` 
from [here](https://github.com/satijalab/seurat/wiki/Seurat#object-information).

We begin by reading the count matrix using `Read10X_h5 reads` count matrix from 10X CellRanger hdf5 file. The Hierarchical Data Format (HDF5 or H5) format provides
a more compressed representation of the data. Seurat package includes multiple read functions depending on the format.

While reading the data, we apply rudimentary quality control to discard low quality cells with less than 200 expressed features (genes) and lowly expressed 
features observed in less than 3 cells. 

```r
pbmc.data <- Read10X_h5(filename="./SC3_v3_NextGem_DI_PBMC_10K_filtered_feature_bc_matrix.h5")
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc10k", min.cells = 3, min.features = 200)
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 15)
```

Next we calculate the percentage contribution of mitochondrial RNA to the total RNA content. High mitochondrial content can be indicative of low quality cells 
undergoing apoptosis. We apply another round of quality control based on the distribution of mitochondrial content and number of features per cell. Too low features
can indicate ambient RNA contamination in empty droplets. Too high features might be caused by multiple cells caught in the same droplet.

```r
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 15)
```
## Data processing

After quality control measures to select cells for further analysis, the next steps involve normalizing the data, identifying highly variable features, and scaling. 
Principal component analysis is also computed as many of the downstream analysis steps will be conducted in a lower dimensionality space.

```r
pbmc <- NormalizeData(pbmc)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
pbmc <- RunPCA(pbmc, verbose = FALSE)
```
The rationale of all the preceeding steps relevant to quality control are covered in much greater detail in an earlier tutorial.

## Choosing the number of principal components

<b>First big decision - how many principal components (PCs) should you retain for your downstream analysis?</b> The more PCs you keep the more signal, also more 
noise, and the compute requirements increase as well. Before you make this choice, examine the genes correlated with each principal component. Presence of cell 
type specific genes would indicate the principal component is informative. Presence of all unrelated gene names would indicate otherwise. In PBMC context, we 
expect the major cell types to be T cells, B cells, NK cells, monocytes and so on.

Examine top 10 PCs, you will see a lot of familiar gene names. 
```r
print(pbmc[["pca"]], dims = 1:10, nfeatures = 5)
```

Examine PCs 40 to 50, the gene names would be be less familiar (at least to most of us). 
```r
print(pbmc[["pca"]], dims = 40:50, nfeatures = 5)
```

Another way of visualising this information is 

```r
VizDimLoadings(pbmc, dims = 1:2, reduction = "pca",balanced=TRUE)
```

Yet another approach which provides a pictorial representation. The cells and features are ordered based on the PCA scores. Setting a cell number helps 
computational efficiency by ignoring the extreme cells which are less informative. Forcing it to be balanced gives an equal representation for both positive and
negative correlations.

```r
DimHeatmap(pbmc, dims = 1, cells = 500, balanced = TRUE)
```
```r
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)
```

Jackstraw plot estimates the significance of the structure captured by each principal component. It randomly permutes a subset of the data to establish the null
distribution against which the p values are estimated.

:warning: This might take a bit of time to execute. Skip if you are running behind and focus only on the elbow plot next

```r
pbmc <- JackStraw(pbmc, num.replicate = 100)
pbmc <- ScoreJackStraw(pbmc, dims = 1:20)
JackStrawPlot(pbmc, dims = 1:20)
```

Elbowplots are the classic computer science way to examine the accumulative variability within the data represented by the addition of each principal 
component.

```r
ElbowPlot(pbmc,ndims=50)
```
Based on these plots, we chose 20 PCs for this workshop. But an argument can be made for any number in the range 15 to 30. 

We use umap to visualise the dataset throughout this workshop. Computing it early before we need it.
```r
pbmc <- RunUMAP(pbmc, dims = 1:20, verbose = FALSE)
```


```r

```
